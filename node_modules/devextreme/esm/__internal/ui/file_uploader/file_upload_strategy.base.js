/**
 * DevExtreme (esm/__internal/ui/file_uploader/file_upload_strategy.base.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    Deferred
} from "../../../core/utils/deferred";
import {
    isDefined,
    isFunction
} from "../../../core/utils/type";
import {
    fromPromise
} from "../../core/utils/m_deferred";
export class FileUploadStrategyBase {
    constructor(fileUploader) {
        this.fileUploader = fileUploader
    }
    upload(file) {
        if (file.isInitialized && file.isAborted) {
            var _this$fileUploader;
            null === (_this$fileUploader = this.fileUploader) || void 0 === _this$fileUploader || _this$fileUploader._resetFileState(file)
        }
        if (file.isValid() && !file.uploadStarted) {
            this._prepareFileBeforeUpload(file);
            this._uploadCore(file)
        }
    }
    abortUpload(file) {
        var _file$request;
        if (file._isError || file._isLoaded || file.isAborted || !file.uploadStarted) {
            return
        }
        file.isAborted = true;
        null === (_file$request = file.request) || void 0 === _file$request || _file$request.abort();
        if (this._isCustomCallback("abortUpload")) {
            const {
                abortUpload: abortUpload
            } = this.fileUploader.option();
            const arg = this._createUploadArgument(file);
            let deferred = null;
            try {
                const result = null === abortUpload || void 0 === abortUpload ? void 0 : abortUpload(file.value, arg);
                deferred = fromPromise(result)
            } catch (error) {
                deferred = Deferred().reject(error).promise()
            }
            if (deferred && "done" in deferred) {
                var _deferred;
                null === (_deferred = deferred) || void 0 === _deferred || _deferred.done((() => file.onAbort.fire())).fail((error => this._handleFileError(file, error)))
            }
        }
    }
    _beforeSend(xhr, file) {
        var _this$fileUploader$_b, _this$fileUploader2;
        const arg = this._createUploadArgument(file);
        null === (_this$fileUploader$_b = (_this$fileUploader2 = this.fileUploader)._beforeSendAction) || void 0 === _this$fileUploader$_b || _this$fileUploader$_b.call(_this$fileUploader2, {
            request: xhr,
            file: file.value,
            uploadInfo: arg
        });
        file.request = xhr
    }
    _createUploadArgument(_file) {
        return {
            bytesUploaded: 0,
            chunkCount: 0,
            customData: {},
            chunkBlob: new Blob,
            chunkIndex: 0
        }
    }
    _uploadCore(_file) {}
    _isCustomCallback(name) {
        var _this$fileUploader3;
        const callback = null === (_this$fileUploader3 = this.fileUploader) || void 0 === _this$fileUploader3 ? void 0 : _this$fileUploader3.option(name);
        return callback && isFunction(callback)
    }
    _handleProgress(file, e) {
        if (file._isError) {
            return
        }
        file._isProgressStarted = true;
        this._handleProgressCore(file, e)
    }
    _handleProgressCore(_file, _e) {}
    _handleFileError(file, error) {
        file._isError = true;
        file.onError.fire(error)
    }
    _prepareFileBeforeUpload(file) {
        if (file.$file) {
            var _file$progressBar;
            null === (_file$progressBar = file.progressBar) || void 0 === _file$progressBar || _file$progressBar.dispose();
            this.fileUploader._createFileProgressBar(file)
        }
        if (file.isInitialized) {
            return
        }
        file.onLoadStart.add(this._onUploadStarted.bind(this, file));
        file.onLoad.add(this._onLoadedHandler.bind(this, file));
        file.onError.add(this._onErrorHandler.bind(this, file));
        file.onAbort.add(this._onAbortHandler.bind(this, file));
        file.onProgress.add(this._onProgressHandler.bind(this, file));
        file.isInitialized = true
    }
    _shouldHandleError(file, e) {
        return (this._isStatusError(e.status) || !file._isProgressStarted) && !file.isAborted
    }
    _isStatusError(status) {
        return status >= 400 && status < 500 || status >= 500 && status < 600
    }
    _onUploadStarted(file, e) {
        var _this$fileUploader4, _this$fileUploader4$_;
        file.uploadStarted = true;
        null === (_this$fileUploader4 = this.fileUploader) || void 0 === _this$fileUploader4 || null === (_this$fileUploader4$_ = _this$fileUploader4._uploadStartedAction) || void 0 === _this$fileUploader4$_ || _this$fileUploader4$_.call(_this$fileUploader4, {
            file: file.value,
            event: e,
            request: file.request
        })
    }
    _onAbortHandler(file, e) {
        var _this$fileUploader5, _this$fileUploader$_u, _this$fileUploader6;
        const args = {
            file: file.value,
            event: e,
            request: file.request,
            message: null === (_this$fileUploader5 = this.fileUploader) || void 0 === _this$fileUploader5 ? void 0 : _this$fileUploader5._getUploadAbortedStatusMessage()
        };
        null === (_this$fileUploader$_u = (_this$fileUploader6 = this.fileUploader)._uploadAbortedAction) || void 0 === _this$fileUploader$_u || _this$fileUploader$_u.call(_this$fileUploader6, args);
        this.fileUploader._setStatusMessage(file, args.message);
        this.fileUploader._handleAllFilesUploaded()
    }
    _onErrorHandler(file, error) {
        var _this$fileUploader$_u2, _this$fileUploader7, _this$fileUploader$_s, _this$fileUploader8;
        const {
            uploadFailedMessage: uploadFailedMessage
        } = this.fileUploader.option();
        const args = {
            file: file.value,
            event: void 0,
            request: file.request,
            error: error,
            message: uploadFailedMessage
        };
        null === (_this$fileUploader$_u2 = (_this$fileUploader7 = this.fileUploader)._uploadErrorAction) || void 0 === _this$fileUploader$_u2 || _this$fileUploader$_u2.call(_this$fileUploader7, args);
        null === (_this$fileUploader$_s = (_this$fileUploader8 = this.fileUploader)._setStatusMessage) || void 0 === _this$fileUploader$_s || _this$fileUploader$_s.call(_this$fileUploader8, file, args.message);
        this.fileUploader._handleAllFilesUploaded()
    }
    _onLoadedHandler(file, e) {
        var _this$fileUploader$_u3, _this$fileUploader9;
        const {
            uploadedMessage: uploadedMessage
        } = this.fileUploader.option();
        const args = {
            file: file.value,
            event: e,
            request: file.request,
            message: uploadedMessage
        };
        file._isLoaded = true;
        null === (_this$fileUploader$_u3 = (_this$fileUploader9 = this.fileUploader)._uploadedAction) || void 0 === _this$fileUploader$_u3 || _this$fileUploader$_u3.call(_this$fileUploader9, args);
        this.fileUploader._setStatusMessage(file, args.message);
        this.fileUploader._handleAllFilesUploaded()
    }
    _onProgressHandler(file, e) {
        if (file) {
            const totalFilesSize = this.fileUploader._getTotalFilesSize();
            const totalLoadedFilesSize = this.fileUploader._getTotalLoadedFilesSize();
            const loaded = e.loaded ?? 0;
            const loadedSize = Math.min(loaded, file.value.size);
            const segmentSize = loadedSize - file.loadedSize;
            file.loadedSize = loadedSize;
            this.fileUploader._updateTotalProgress(totalFilesSize, totalLoadedFilesSize + segmentSize);
            this.fileUploader._updateProgressBar(file, this._getLoadedData(loadedSize, e.total, segmentSize, e))
        }
    }
    _getLoadedData(loaded, total, currentSegmentSize, _event) {
        return {
            loaded: loaded,
            total: total,
            currentSegmentSize: currentSegmentSize
        }
    }
    _extendFormData(formData) {
        const {
            uploadCustomData: formDataEntries
        } = this.fileUploader.option();
        for (const entryName in formDataEntries) {
            if (Object.prototype.hasOwnProperty.call(formDataEntries, entryName) && isDefined(formDataEntries[entryName])) {
                formData.append(entryName, formDataEntries[entryName])
            }
        }
    }
}
