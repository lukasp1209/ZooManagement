/**
 * DevExtreme (esm/__internal/ui/shared/ui.editor_factory_mixin.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import "../../../ui/text_box";
import "../../../ui/number_box";
import "../../../ui/check_box";
import "../../../ui/select_box";
import "../../../ui/date_box";
import eventsEngine from "../../../common/core/events/core/events_engine";
import {
    normalizeKeyName
} from "../../../common/core/events/utils/index";
import {
    normalizeDataSourceOptions
} from "../../../common/data/data_source/utils";
import devices from "../../../core/devices";
import {
    getPublicElement
} from "../../../core/element";
import $ from "../../../core/renderer";
import browser from "../../../core/utils/browser";
import {
    compileGetter
} from "../../../core/utils/data";
import {
    extend
} from "../../../core/utils/extend";
import {
    isDefined,
    isFunction,
    isObject
} from "../../../core/utils/type";
import variableWrapper from "../../../core/utils/variable_wrapper";
const {
    isWrapped: isWrapped
} = variableWrapper;
const CHECKBOX_SIZE_CLASS = "checkbox-size";
const EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
const getResultConfig = (config, options) => extend(config, {
    readOnly: options.readOnly,
    placeholder: options.placeholder,
    inputAttr: {
        id: options.id,
        "aria-labelledby": options["aria-labelledby"]
    },
    tabIndex: options.tabIndex
}, options.editorOptions);
const checkEnterBug = () => browser.mozilla || devices.real().ios;
const getTextEditorConfig = options => {
    const data = {};
    const isEnterBug = checkEnterBug();
    const sharedData = options.sharedData || data;
    return getResultConfig({
        placeholder: options.placeholder,
        width: options.width,
        value: options.value,
        onValueChanged(e) {
            const needDelayedUpdate = "filterRow" === options.parentType || "searchPanel" === options.parentType;
            const isInputOrKeyUpEvent = e.event && ("input" === e.event.type || "keyup" === e.event.type);
            const updateValue = function(e, notFireEvent) {
                null === options || void 0 === options || options.setValue(e.value, notFireEvent)
            };
            clearTimeout(data.valueChangeTimeout);
            if (isInputOrKeyUpEvent && needDelayedUpdate) {
                sharedData.valueChangeTimeout = data.valueChangeTimeout = setTimeout((() => {
                    updateValue(e, data.valueChangeTimeout !== sharedData.valueChangeTimeout)
                }), isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0)
            } else {
                updateValue(e)
            }
        },
        onKeyDown(e) {
            if (isEnterBug && "enter" === normalizeKeyName(e.event)) {
                eventsEngine.trigger($(e.component._input()), "change")
            }
        },
        valueChangeEvent: "change" + ("filterRow" === options.parentType ? " keyup input" : "")
    }, options)
};

function watchLookupDataSource(options) {
    var _options$row;
    if (null !== (_options$row = options.row) && void 0 !== _options$row && _options$row.watch && "dataRow" === options.parentType) {
        const editorOptions = options.editorOptions || {};
        options.editorOptions = editorOptions;
        let selectBox;
        const {
            onInitialized: onInitialized
        } = editorOptions;
        editorOptions.onInitialized = function(e) {
            null === onInitialized || void 0 === onInitialized || onInitialized.apply(this, arguments);
            selectBox = e.component;
            selectBox.on("disposing", stopWatch)
        };
        let dataSource;
        const stopWatch = options.row.watch((() => {
            var _dataSource;
            dataSource = options.lookup.dataSource(options.row);
            return null === (_dataSource = dataSource) || void 0 === _dataSource ? void 0 : _dataSource.filter
        }), (() => {
            selectBox.option("dataSource", dataSource)
        }), (row => {
            options.row = row
        }))
    }
}
const prepareDateBox = options => {
    options.editorName = "dxDateBox";
    options.editorOptions = getResultConfig({
        value: options.value,
        onValueChanged(args) {
            options.setValue(args.value)
        },
        onKeyDown(_ref) {
            let {
                component: component,
                event: event
            } = _ref;
            const useMaskBehavior = component.option("useMaskBehavior");
            if ((checkEnterBug() || useMaskBehavior) && "enter" === normalizeKeyName(event)) {
                component.blur();
                component.focus()
            }
        },
        displayFormat: options.format,
        type: options.dataType,
        dateSerializationFormat: null,
        width: "filterBuilder" === options.parentType ? void 0 : "auto"
    }, options)
};
const prepareTextBox = options => {
    const config = getTextEditorConfig(options);
    const isSearching = "searchPanel" === options.parentType;
    if (options.editorType && "dxTextBox" !== options.editorType) {
        config.value = options.value
    } else {
        config.value = (value = options.value, isDefined(value) ? value.toString() : "")
    }
    var value;
    config.valueChangeEvent += isSearching ? " keyup input search" : "";
    config.mode = config.mode || (isSearching ? "search" : "text");
    options.editorName = "dxTextBox";
    options.editorOptions = config
};
const prepareNumberBox = options => {
    const config = getTextEditorConfig(options);
    config.value = isDefined(options.value) ? options.value : null;
    options.editorName = "dxNumberBox";
    options.editorOptions = config
};

function prepareLookupEditor(options) {
    const {
        lookup: lookup
    } = options;
    let displayGetter;
    let dataSource;
    let postProcess;
    const isFilterRow = "filterRow" === options.parentType;
    if (lookup) {
        displayGetter = compileGetter(lookup.displayExpr);
        dataSource = lookup.dataSource;
        if (isFunction(dataSource) && !isWrapped(dataSource)) {
            dataSource = dataSource(options.row || {});
            watchLookupDataSource(options)
        }
        if (isObject(dataSource) || Array.isArray(dataSource)) {
            dataSource = normalizeDataSourceOptions(dataSource);
            if (isFilterRow) {
                postProcess = dataSource.postProcess;
                dataSource.postProcess = function(items) {
                    if (0 === this.pageIndex()) {
                        items = items.slice(0);
                        items.unshift(null)
                    }
                    if (postProcess) {
                        return postProcess.call(this, items)
                    }
                    return items
                }
            }
        }
        const allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
        options.editorName = options.editorType ?? "dxSelectBox";
        options.editorOptions = getResultConfig({
            searchEnabled: true,
            value: options.value,
            valueExpr: options.lookup.valueExpr,
            searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
            allowClearing: allowClearing,
            showClearButton: allowClearing,
            displayExpr(data) {
                if (null === data) {
                    return options.showAllText
                }
                return displayGetter(data)
            },
            dataSource: dataSource,
            onValueChanged(e) {
                const params = [e.value];
                if (!isFilterRow) {
                    params.push(e.component.option("text"))
                }
                options.setValue.apply(this, params)
            }
        }, options)
    }
}

function prepareCheckBox(options) {
    options.editorName = "dxCheckBox";
    options.editorOptions = getResultConfig({
        elementAttr: {
            id: options.id
        },
        value: isDefined(options.value) ? options.value : void 0,
        hoverStateEnabled: !options.readOnly,
        focusStateEnabled: !options.readOnly,
        activeStateEnabled: false,
        onValueChanged(e) {
            var _options$setValue;
            null === (_options$setValue = options.setValue) || void 0 === _options$setValue || _options$setValue.call(options, e.value, e)
        }
    }, options)
}
const prepareBooleanEditor = options => {
    if ("filterRow" === options.parentType || "filterBuilder" === options.parentType) {
        prepareLookupEditor(extend(options, {
            lookup: {
                displayExpr(data) {
                    if (true === data) {
                        return options.trueText || "true"
                    }
                    if (false === data) {
                        return options.falseText || "false"
                    }
                },
                dataSource: [true, false]
            }
        }))
    } else {
        prepareCheckBox(options)
    }
};
const createEditorCore = (that, options) => {
    const $editorElement = $(options.editorElement);
    if (options.editorName && options.editorOptions && $editorElement[options.editorName]) {
        if ("dxCheckBox" === options.editorName || "dxSwitch" === options.editorName) {
            if (!options.isOnForm) {
                $editorElement.addClass(that.addWidgetPrefix("checkbox-size"));
                $editorElement.parent().addClass(EDITOR_INLINE_BLOCK)
            }
        }
        that._createComponent($editorElement, options.editorName, options.editorOptions);
        if ("dxDateBox" === options.editorName) {
            const dateBox = $editorElement.dxDateBox("instance");
            const defaultEnterKeyHandler = dateBox._supportedKeys().enter;
            dateBox.registerKeyHandler("enter", (e => {
                if (dateBox.option("opened")) {
                    defaultEnterKeyHandler(e)
                }
                return true
            }))
        }
        if ("dxTextArea" === options.editorName) {
            $editorElement.dxTextArea("instance").registerKeyHandler("enter", (event => {
                if ("enter" === normalizeKeyName(event) && !event.ctrlKey && !event.shiftKey) {
                    event.stopPropagation()
                }
            }))
        }
    }
};
const prepareCustomEditor = options => {
    options.editorName = options.editorType;
    options.editorOptions = getResultConfig({
        value: options.value,
        onValueChanged(args) {
            options.setValue(args.value)
        }
    }, options)
};
const prepareEditor = options => {
    const prepareDefaultEditor = {
        dxDateBox: prepareDateBox,
        dxCheckBox: prepareCheckBox,
        dxNumberBox: prepareNumberBox,
        dxTextBox: prepareTextBox
    };
    if (options.lookup) {
        prepareLookupEditor(options)
    } else if (options.editorType) {
        (prepareDefaultEditor[options.editorType] ?? prepareCustomEditor)(options)
    } else {
        switch (options.dataType) {
            case "date":
            case "datetime":
                prepareDateBox(options);
                break;
            case "boolean":
                prepareBooleanEditor(options);
                break;
            case "number":
                prepareNumberBox(options);
                break;
            default:
                prepareTextBox(options)
        }
    }
};
const EditorFactoryMixin = Base => class extends Base {
    createEditor($container, options) {
        options.cancel = false;
        options.editorElement = getPublicElement($container);
        if (!isDefined(options.tabIndex)) {
            options.tabIndex = this.option("tabIndex")
        }
        prepareEditor(options);
        this.executeAction("onEditorPreparing", options);
        if (options.cancel) {
            return
        }
        if ("dataRow" === options.parentType && !options.isOnForm && !isDefined(options.editorOptions.showValidationMark)) {
            options.editorOptions.showValidationMark = false
        }
        createEditorCore(this, options);
        this.executeAction("onEditorPrepared", options)
    }
};
export default EditorFactoryMixin;
