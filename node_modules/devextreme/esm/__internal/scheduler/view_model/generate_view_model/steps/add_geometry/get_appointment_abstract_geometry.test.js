/**
 * DevExtreme (esm/__internal/scheduler/view_model/generate_view_model/steps/add_geometry/get_appointment_abstract_geometry.test.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    describe,
    expect,
    it
} from "@jest/globals";
import {
    getAppointmentX,
    getAppointmentY
} from "./get_appointment_abstract_geometry";
describe("appointment position utils", (() => {
    describe("getAppointmentX", (() => {
        const cellSize = {
            sizeX: 200,
            sizeY: 100
        };
        const cells = [{
            min: 0,
            max: 20,
            cellIndex: 0,
            columnIndex: 0,
            rowIndex: 0
        }, {
            min: 20,
            max: 40,
            cellIndex: 1,
            columnIndex: 1,
            rowIndex: 0
        }, {
            min: 50,
            max: 70,
            cellIndex: 2,
            columnIndex: 2,
            rowIndex: 0
        }, {
            min: 70,
            max: 90,
            cellIndex: 3,
            columnIndex: 3,
            rowIndex: 0
        }];
        it("should return X position inside one cell", (() => {
            expect(getAppointmentX({
                startDateUTC: 10,
                endDateUTC: 15,
                cellIndex: 0,
                endCellIndex: 0,
                columnIndex: 0
            }, cellSize, cells)).toEqual({
                offsetX: 100,
                sizeX: 50
            })
        }));
        it("should return X position inside cells with gap", (() => {
            expect(getAppointmentX({
                startDateUTC: 22,
                endDateUTC: 72,
                cellIndex: 1,
                endCellIndex: 3,
                columnIndex: 1
            }, cellSize, cells)).toEqual({
                offsetX: 220,
                sizeX: 400
            })
        }));
        it("should return correct X position through DST", (() => {
            const entity = {
                startDateUTC: Date.UTC(2019, 9, 26),
                endDateUTC: Date.UTC(2019, 9, 29),
                cellIndex: 0,
                endCellIndex: 1,
                columnIndex: 0
            };
            expect(getAppointmentX(entity, cellSize, [{
                min: Date.UTC(2019, 9, 25),
                max: Date.UTC(2019, 9, 27),
                cellIndex: 0,
                columnIndex: 0,
                rowIndex: 0
            }, {
                min: Date.UTC(2019, 9, 27),
                max: Date.UTC(2019, 9, 29),
                cellIndex: 1,
                columnIndex: 1,
                rowIndex: 0
            }])).toEqual({
                offsetX: 100,
                sizeX: 300
            })
        }))
    }));
    describe("getAppointmentY", (() => {
        it("should return Y position inside interval according to level for collector at the start", (() => {
            expect(getAppointmentY({
                level: 4,
                maxLevel: 10,
                isAllDayPanelOccupied: false,
                inStackWithCollector: false
            }, {
                sizeX: 200,
                sizeY: 105
            }, 5, "start")).toEqual({
                offsetY: 45,
                sizeY: 10
            })
        }));
        it("should return Y position inside interval according to level for collector at the end", (() => {
            expect(getAppointmentY({
                level: 7,
                maxLevel: 10,
                isAllDayPanelOccupied: false,
                inStackWithCollector: false
            }, {
                sizeX: 200,
                sizeY: 105
            }, 5, "end")).toEqual({
                offsetY: 70,
                sizeY: 10
            })
        }));
        it("should return Y position for all day panel at the beginning of cell", (() => {
            expect(getAppointmentY({
                level: 0,
                maxLevel: 1,
                isAllDayPanelOccupied: true,
                inStackWithCollector: false
            }, {
                sizeX: 200,
                sizeY: 105
            }, 5, "end")).toEqual({
                offsetY: 0,
                sizeY: 100
            })
        }))
    }))
}));
