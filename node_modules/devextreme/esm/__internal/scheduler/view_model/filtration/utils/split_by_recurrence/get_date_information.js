/**
 * DevExtreme (esm/__internal/scheduler/view_model/filtration/utils/split_by_recurrence/get_date_information.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import dateUtils from "../../../../../../core/utils/date";
import {
    globalCache
} from "../../../../global_cache";
import timeZoneUtils from "../../../../m_utils_time_zone";
const toMs = dateUtils.dateToMilliseconds;
const getOffsetHours = timeZoneUtils.calculateTimezoneByValue;
const HOUR_MS = toMs("hour");
const roundToHour = date => Math.round(date / HOUR_MS) * HOUR_MS;
export const findDSTOfDay = (date, timeZone) => {
    const minDate = new Date(date).setUTCHours(0, 0, 0, 0);
    return globalCache.DST.memo(`${minDate}${timeZone}`, (() => {
        const min = roundToHour(minDate - HOUR_MS);
        const max = roundToHour(minDate + toMs("day") + HOUR_MS);
        const minOffset = getOffsetHours(timeZone, min) ?? 0;
        const maxOffset = getOffsetHours(timeZone, max) ?? 0;
        if (minOffset === maxOffset) {
            return [-date, minOffset * HOUR_MS, maxOffset * HOUR_MS]
        }
        let left = min;
        let right = max;
        while (right - left > HOUR_MS / 3) {
            const mid = left + (right - left) / 2;
            const offset = getOffsetHours(timeZone, roundToHour(mid));
            if (offset === minOffset) {
                left = mid
            } else {
                right = mid
            }
        }
        return [roundToHour(left) + HOUR_MS, minOffset * HOUR_MS, maxOffset * HOUR_MS]
    }))
};
export const getDateInformation = (date, timeZone) => {
    const [targetDST, beforeDSTOffset, afterDSTOffset] = findDSTOfDay(date, timeZone);
    const deltaMs = afterDSTOffset - beforeDSTOffset;
    const condition = deltaMs > 0 ? date < targetDST + deltaMs : date < targetDST;
    return {
        offsetMs: condition ? beforeDSTOffset : afterDSTOffset,
        isUnreachableTime: deltaMs > 0 && date >= targetDST && date < targetDST + deltaMs,
        isDoubleTimeStart: date === targetDST,
        deltaMs: deltaMs
    }
};
export const getDateOffsetMs = (date, timeZone) => timeZone ? getDateInformation(date, timeZone).offsetMs : 0;
