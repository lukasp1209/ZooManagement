/**
 * DevExtreme (esm/__internal/core/localization/intl/number.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import dxConfig from "../../../../core/config";
import accountingFormats from "../../../core/localization/cldr-data/accounting_formats";
import localizationCoreUtils from "../../../core/localization/core";
import openXmlCurrencyFormat from "../../../core/localization/open_xml_currency_format";
const CURRENCY_STYLES = ["standard", "accounting"];
const MAX_FRACTION_DIGITS = 20;
const detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
const formattersCache = {};
const getFormatter = format => {
    const key = `${localizationCoreUtils.locale()}/${JSON.stringify(format)}`;
    if (!formattersCache[key]) {
        formattersCache[key] = new Intl.NumberFormat(localizationCoreUtils.locale(), format).format
    }
    return formattersCache[key]
};
const getCurrencyFormatter = currency => new Intl.NumberFormat(localizationCoreUtils.locale(), {
    style: "currency",
    currency: currency
});
export default {
    engine: () => "intl",
    _formatNumberCore(value, format, formatConfig) {
        if ("exponential" === format) {
            return this.callBase.apply(this, [value, format, formatConfig])
        }
        return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value)
    },
    _normalizeFormatConfig(format, formatConfig, value) {
        let config;
        if ("decimal" === format) {
            const fractionDigits = String(value).split(".")[1];
            config = {
                minimumIntegerDigits: formatConfig.precision || void 0,
                useGrouping: false,
                maximumFractionDigits: null === fractionDigits || void 0 === fractionDigits ? void 0 : fractionDigits.length,
                round: value < 0 ? "ceil" : "floor"
            }
        } else {
            config = this._getPrecisionConfig(formatConfig.precision)
        }
        if ("percent" === format) {
            config.style = "percent"
        } else if ("currency" === format) {
            const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? dxConfig().defaultUseCurrencyAccountingStyle;
            config.style = "currency";
            config.currency = formatConfig.currency || dxConfig().defaultCurrency;
            config.currencySign = CURRENCY_STYLES[+useAccountingStyle]
        }
        return config
    },
    _getPrecisionConfig(precision) {
        let config;
        if (null === precision) {
            config = {
                minimumFractionDigits: 0,
                maximumFractionDigits: 20
            }
        } else {
            config = {
                minimumFractionDigits: precision || 0,
                maximumFractionDigits: precision || 0
            }
        }
        return config
    },
    format(value, format) {
        if ("number" !== typeof value) {
            return value
        }
        format = this._normalizeFormat(format);
        if ("default" === format.currency) {
            format.currency = dxConfig().defaultCurrency
        }
        if (!format || "function" !== typeof format && !format.type && !format.formatter) {
            return getFormatter(format)(value)
        }
        return this.callBase.apply(this, [value, format])
    },
    _getCurrencySymbolInfo(currency) {
        const formatter = getCurrencyFormatter(currency);
        return this._extractCurrencySymbolInfo(formatter.format(0))
    },
    _extractCurrencySymbolInfo(currencyValueString) {
        const match = detectCurrencySymbolRegex.exec(currencyValueString) || [];
        const position = match[1] ? "before" : "after";
        const symbol = match[1] || match[4] || "";
        const delimiter = match[2] || match[3] || "";
        return {
            position: position,
            symbol: symbol,
            delimiter: delimiter
        }
    },
    getCurrencySymbol(currency) {
        if (!currency) {
            currency = dxConfig().defaultCurrency
        }
        const symbolInfo = this._getCurrencySymbolInfo(currency);
        return {
            symbol: symbolInfo.symbol
        }
    },
    getOpenXmlCurrencyFormat(currency) {
        const targetCurrency = currency || dxConfig().defaultCurrency;
        const currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
        const closestAccountingFormat = localizationCoreUtils.getValueByClosestLocale((locale => accountingFormats[locale]));
        return openXmlCurrencyFormat(currencySymbol, closestAccountingFormat)
    }
};
