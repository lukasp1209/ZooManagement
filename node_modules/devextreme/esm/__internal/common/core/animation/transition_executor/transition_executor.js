/**
 * DevExtreme (esm/__internal/common/core/animation/transition_executor/transition_executor.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import fx from "../../../../../common/core/animation/fx";
import Class from "../../../../../core/class";
import $ from "../../../../../core/renderer";
import {
    Deferred,
    when
} from "../../../../../core/utils/deferred";
import {
    extend
} from "../../../../../core/utils/extend";
import {
    map
} from "../../../../../core/utils/iterator";
import {
    isFunction,
    isPlainObject
} from "../../../../../core/utils/type";
import {
    presets
} from "../../../../common/core/animation/presets/m_presets";
import commonUtils from "../../../../core/utils/m_common";
const directionPostfixes = {
    forward: " dx-forward",
    backward: " dx-backward",
    none: " dx-no-direction",
    undefined: " dx-no-direction"
};
const DX_ANIMATING_CLASS = "dx-animating";
export const TransitionExecutor = Class.inherit({
    ctor() {
        this._accumulatedDelays = {
            enter: 0,
            leave: 0
        };
        this._animations = [];
        this.reset()
    },
    _createAnimations($elements, initialConfig, configModifier, type) {
        $elements = $($elements);
        const that = this;
        const result = [];
        configModifier = configModifier || {};
        const animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
        if (animationConfig) {
            $elements.each((function() {
                const animation = that._createAnimation($(this), animationConfig, configModifier);
                if (animation) {
                    animation.element.addClass("dx-animating");
                    animation.setup();
                    result.push(animation)
                }
            }))
        }
        return result
    },
    _prepareElementAnimationConfig(config, configModifier, type) {
        let result;
        if ("string" === typeof config) {
            const presetName = config;
            config = presets.getPreset(presetName)
        }
        if (!config) {
            result = void 0
        } else if (isFunction(config[type])) {
            result = config[type]
        } else {
            result = extend({
                skipElementInitialStyles: true,
                cleanupWhen: this._completePromise
            }, config, configModifier);
            if (!result.type || "css" === result.type) {
                const cssClass = `dx-${type}`;
                const extraCssClasses = (result.extraCssClasses ? ` ${result.extraCssClasses}` : "") + directionPostfixes[result.direction];
                result.type = "css";
                result.from = (result.from || cssClass) + extraCssClasses;
                result.to = result.to || `${cssClass}-active`
            }
            result.staggerDelay = result.staggerDelay || 0;
            result.delay = result.delay || 0;
            if (result.staggerDelay) {
                result.delay += this._accumulatedDelays[type];
                this._accumulatedDelays[type] += result.staggerDelay
            }
        }
        return result
    },
    _createAnimation($element, animationConfig, configModifier) {
        let result;
        if (isPlainObject(animationConfig)) {
            result = fx.createAnimation($element, animationConfig)
        } else if (isFunction(animationConfig)) {
            result = animationConfig($element, configModifier)
        }
        return result
    },
    _startAnimations() {
        const animations = this._animations;
        for (let i = 0; i < animations.length; i += 1) {
            animations[i].start()
        }
    },
    _stopAnimations(jumpToEnd) {
        const animations = this._animations;
        for (let i = 0; i < animations.length; i += 1) {
            animations[i].stop(jumpToEnd)
        }
    },
    _clearAnimations() {
        const animations = this._animations;
        for (let i = 0; i < animations.length; i += 1) {
            animations[i].element.removeClass("dx-animating")
        }
        this._animations.length = 0
    },
    reset() {
        this._accumulatedDelays.enter = 0;
        this._accumulatedDelays.leave = 0;
        this._clearAnimations();
        this._completeDeferred = new Deferred;
        this._completePromise = this._completeDeferred.promise()
    },
    enter($elements, animationConfig, configModifier) {
        const animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
        this._animations.push.apply(this._animations, animations)
    },
    leave($elements, animationConfig, configModifier) {
        const animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
        this._animations.push.apply(this._animations, animations)
    },
    start() {
        const that = this;
        let result;
        if (!this._animations.length) {
            that.reset();
            result = (new Deferred).resolve().promise()
        } else {
            const animationDeferreds = map(this._animations, (animation => {
                const result = new Deferred;
                animation.deferred.always((() => {
                    result.resolve()
                }));
                return result.promise()
            }));
            result = when.apply($, animationDeferreds).always((() => {
                that._completeDeferred.resolve();
                that.reset()
            }));
            commonUtils.executeAsync((() => {
                that._startAnimations()
            }))
        }
        return result
    },
    stop(jumpToEnd) {
        this._stopAnimations(jumpToEnd)
    }
});
