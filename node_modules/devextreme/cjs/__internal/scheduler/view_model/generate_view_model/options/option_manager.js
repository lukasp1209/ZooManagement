/**
 * DevExtreme (cjs/__internal/scheduler/view_model/generate_view_model/options/option_manager.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptionManager = void 0;
var _global_cache = require("../../../global_cache");
var _get_group_size = require("./get_group_size");
var _get_month_intervals = require("./get_month_intervals");
var _get_panel_collector_options = require("./get_panel_collector_options");
var _get_view_model_options = require("./get_view_model_options");
var _get_week_intervals = require("./get_week_intervals");
const getLayoutIntervals = (compareOptions, cellDurationMinutes, viewOffset, isTimeline, isMonthView, panelName) => {
    switch (true) {
        case isMonthView:
            return (0, _get_month_intervals.getMonthIntervals)(compareOptions, viewOffset, isTimeline);
        case "allDayPanel" === panelName:
            return (0, _get_month_intervals.getMonthIntervals)(compareOptions, viewOffset, true);
        default:
            return (0, _get_week_intervals.getWeekIntervals)(compareOptions, cellDurationMinutes, viewOffset, isTimeline)
    }
};
class OptionManager {
    constructor(schedulerStore) {
        this.schedulerStore = schedulerStore;
        this.cache = new _global_cache.Cache;
        this.options = (0, _get_view_model_options.getViewModelOptions)(schedulerStore)
    }
    getPanelOptions(panelName) {
        const workspace = this.schedulerStore.getWorkSpace();
        const panelDOMSize = workspace.getPanelDOMSize("vertical" === this.options.groupOrientation ? "regularPanel" : panelName);
        return this.cache.memo(`${panelDOMSize.width}.${panelDOMSize.height}.${panelName}`, (() => {
            const {
                type: type,
                viewOffset: viewOffset,
                groupOrientation: groupOrientation,
                viewOrientation: nativeViewOrientation,
                isGroupByDate: isGroupByDate,
                groupCount: groupCount,
                compareOptions: compareOptions,
                isMonthView: isMonthView,
                isRTLEnabled: isRTLEnabled,
                isAdaptivityEnabled: isAdaptivityEnabled,
                cellDurationMinutes: cellDurationMinutes,
                isTimelineView: isTimelineView,
                hasAllDayPanel: hasAllDayPanel
            } = this.options;
            const viewOrientation = "allDayPanel" === panelName ? "horizontal" : nativeViewOrientation;
            const isCompactCollector = isAdaptivityEnabled || "vertical" === viewOrientation;
            const collectorCSS = workspace.getCollectorDimension(isCompactCollector, panelName);
            const {
                allDayPanelCellSize: allDayPanelCellSize,
                cellSize: cellSize,
                collectorSizes: collectorSizes,
                maxLevel: maxLevel,
                minLevel: minLevel
            } = (0, _get_panel_collector_options.getPanelCollectorOptions)(this.schedulerStore, {
                alwaysReserveSpaceForCollector: "month" === type,
                isTimelineView: isTimelineView,
                viewOrientation: viewOrientation,
                isAdaptivityEnabled: isAdaptivityEnabled,
                collectorCSS: collectorCSS,
                DOMMetaData: workspace.getDOMElementsMetaData(),
                panelName: panelName
            });
            const {
                cells: cells,
                dayIntervals: dayIntervals,
                intervals: intervals
            } = getLayoutIntervals(compareOptions, cellDurationMinutes, viewOffset, isTimelineView || "allDayPanel" === panelName, isMonthView, panelName);
            const groupByDateSplitIntervals = "vertical" === viewOrientation ? dayIntervals : cells;
            const splitIntervals = isGroupByDate ? groupByDateSplitIntervals : intervals;
            const geometryOptions = Object.assign({
                intervals: intervals,
                cells: cells,
                maxAppointmentsPerCell: maxLevel,
                hasAllDayPanel: hasAllDayPanel,
                viewOrientation: viewOrientation,
                groupOrientation: groupOrientation,
                isGroupByDate: isGroupByDate,
                isTimelineView: isTimelineView,
                isRTLEnabled: isRTLEnabled,
                isAdaptivityEnabled: isAdaptivityEnabled,
                allDayPanelCellSize: allDayPanelCellSize,
                cellSize: cellSize,
                collectorPosition: "vertical" === viewOrientation ? "end" : "start"
            }, collectorSizes, {
                groupCount: groupCount,
                groupSize: (0, _get_group_size.getGroupSize)(Object.assign({}, compareOptions, {
                    cellSize: cellSize,
                    cellDurationMinutes: cellDurationMinutes,
                    intervals: intervals,
                    cells: cells,
                    viewType: type,
                    isAllDayPanel: "allDayPanel" === panelName
                })),
                panelSize: panelDOMSize
            });
            const collectorOptions = {
                cells: cells,
                minLevel: minLevel,
                maxLevel: maxLevel,
                collectBy: "horizontal" === viewOrientation ? "byOccupation" : "byStartDate",
                isCompact: isCompactCollector
            };
            return {
                splitIntervals: splitIntervals,
                cells: cells,
                collectorOptions: collectorOptions,
                geometryOptions: geometryOptions
            }
        }))
    }
    getSplitIntervals(panelName) {
        return this.getPanelOptions(panelName).splitIntervals
    }
    getCells(panelName) {
        return this.getPanelOptions(panelName).cells
    }
    getCollectorOptions(panelName) {
        return this.getPanelOptions(panelName).collectorOptions
    }
    getGeometryOptions(panelName) {
        return this.getPanelOptions(panelName).geometryOptions
    }
    getVirtualCropOptions() {
        const {
            cellSize: cellSize,
            panelSize: panelSize
        } = this.getPanelOptions("regularPanel").geometryOptions;
        const {
            positionHelper: positionHelper,
            virtualScrollingDispatcher: virtualScrollingDispatcher
        } = this.schedulerStore.getWorkSpace();
        const {
            hasAllDayPanel: hasAllDayPanel,
            groupCount: groupCount,
            groupOrientation: groupOrientation,
            isVirtualScrolling: isVirtualScrolling,
            isRTLEnabled: isRTLEnabled
        } = this.options;
        const {
            cellCountInsideLeftVirtualCell: cellCountInsideLeftVirtualCell,
            cellCountInsideRightVirtualCell: cellCountInsideRightVirtualCell,
            cellCountInsideTopVirtualRow: cellCountInsideTopVirtualRow
        } = virtualScrollingDispatcher;
        const hVirtualItemsCount = isRTLEnabled ? cellCountInsideRightVirtualCell : cellCountInsideLeftVirtualCell;
        const isVerticalGrouping = groupCount > 0 && "vertical" === groupOrientation;
        const isGroupedAllDayPanel = isVerticalGrouping && hasAllDayPanel;
        return {
            isVirtualScrolling: isVirtualScrolling,
            getVirtualScreen: groupIndex => this.cache.memo(`virtualScreen${groupIndex}`, (() => {
                const left = hVirtualItemsCount * cellSize.width;
                const top = cellCountInsideTopVirtualRow * cellSize.height;
                const right = Math.round(positionHelper.getHorizontalMax(groupIndex)) || 1 / 0;
                const bottom = positionHelper.getVerticalMax({
                    groupIndex: groupIndex,
                    isVirtualScrolling: isVirtualScrolling,
                    showAllDayPanel: hasAllDayPanel,
                    supportAllDayRow: hasAllDayPanel,
                    isGroupedAllDayPanel: isGroupedAllDayPanel,
                    isVerticalGrouping: isVerticalGrouping
                });
                return {
                    left: isRTLEnabled ? panelSize.width - right : left,
                    right: isRTLEnabled ? panelSize.width - left : right,
                    top: top,
                    bottom: bottom
                }
            }))
        }
    }
}
exports.OptionManager = OptionManager;
