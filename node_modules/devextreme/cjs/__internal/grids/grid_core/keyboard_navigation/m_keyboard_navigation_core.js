/**
 * DevExtreme (cjs/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation_core.js)
 * Version: 25.2.3
 * Build date: Fri Dec 12 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyboardNavigationController = void 0;
var _events_engine = _interopRequireDefault(require("../../../../common/core/events/core/events_engine"));
var _short = require("../../../../common/core/events/short");
var _renderer = _interopRequireDefault(require("../../../../core/renderer"));
var _deferred = require("../../../../core/utils/deferred");
var _position = require("../../../../core/utils/position");
var _get_element_location_internal = require("../../../ui/scroll_view/utils/get_element_location_internal");
var _m_modules = _interopRequireDefault(require("../m_modules"));
var _m_utils = _interopRequireDefault(require("../m_utils"));
var _const = require("./const");
var _m_keyboard_navigation_utils = require("./m_keyboard_navigation_utils");

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
class KeyboardNavigationController extends _m_modules.default.ViewController {
    constructor() {
        super(...arguments);
        this.needToRestoreFocus = false
    }
    _applyColumnIndexBoundaries(columnIndex) {
        const visibleColumnCount = this._columnsController.getVisibleColumns(null, true).length;
        if (columnIndex < 0) {
            columnIndex = 0
        } else if (columnIndex >= visibleColumnCount) {
            columnIndex = visibleColumnCount - 1
        }
        return columnIndex
    }
    unsubscribeFromKeyDownEvent() {
        if (this.keyDownListener) {
            _short.keyboard.off(this.keyDownListener)
        }
    }
    subscribeToKeyDownEvent() {
        const $focusedViewElement = this.getFocusedViewElement();
        if ($focusedViewElement) {
            this.keyDownListener = _short.keyboard.on($focusedViewElement, null, (e => this.keyDownHandler(e)))
        }
    }
    unsubscribeFromFocusinEvent() {
        const $focusedView = this.getFocusedViewElement();
        if ($focusedView) {
            _events_engine.default.off($focusedView, "focusin", this.focusinHandlerContext)
        }
    }
    subscribeToFocusinEvent() {
        const $focusedView = this.getFocusedViewElement();
        const focusinSelector = this.getFocusinSelector();
        if ($focusedView) {
            _events_engine.default.on($focusedView, "focusin", focusinSelector, this.focusinHandlerContext)
        }
    }
    getScrollPadding($container) {
        const containerRect = (0, _position.getBoundingRect)($container.get(0));
        const containerBoundingRect = this.getContainerBoundingRect($container);
        return {
            left: containerBoundingRect.left - containerRect.left,
            right: containerRect.right - containerBoundingRect.right
        }
    }
    getVirtualCellWidth() {
        var _this$_focusedCellPos;
        const visibleColumns = this._columnsController.getVisibleColumns(void 0, true);
        const widths = _m_utils.default.getColumnWidths(visibleColumns);
        const focusedColumnIndex = (null === (_this$_focusedCellPos = this._focusedCellPosition) || void 0 === _this$_focusedCellPos ? void 0 : _this$_focusedCellPos.columnIndex) ?? 0;
        return widths[focusedColumnIndex] ?? 0
    }
    getNextCellLocation($cell, direction) {
        var _this$getFocusedView;
        const scrollable = this.getScrollable();
        const isVirtualColumnRender = this._isVirtualColumnRender();
        if (!scrollable || null === $cell && !isVirtualColumnRender) {
            return 0
        }
        if (null === $cell) {
            const isLeftDirection = "previous" === direction || "previousInRow" === direction;
            const multiplier = isLeftDirection !== this.option("rtlEnabled") ? -1 : 1;
            return scrollable.scrollLeft() + multiplier * this.getVirtualCellWidth()
        }
        const scrollPadding = this.getScrollPadding((0, _renderer.default)(scrollable.container()));
        return (0, _get_element_location_internal.getElementLocationInternal)($cell[0], "horizontal", (0, _renderer.default)(null === (_this$getFocusedView = this.getFocusedView()) || void 0 === _this$getFocusedView ? void 0 : _this$getFocusedView.getContent())[0], scrollable.scrollOffset(), scrollPadding, this.addWidgetPrefix("table"))
    }
    resizeCompleted() {}
    getColumnIndexOffset(visibleIndex) {
        let offset = 0;
        const column = this._columnsController.getVisibleColumns()[visibleIndex];
        if (null !== column && void 0 !== column && column.fixed) {
            offset = this._getFixedColumnIndexOffset(column)
        } else if (visibleIndex >= 0) {
            offset = this._columnsController.getColumnIndexOffset()
        }
        return offset
    }
    getFocusedViewElement() {
        var _this$getFocusedView2;
        return null === (_this$getFocusedView2 = this.getFocusedView()) || void 0 === _this$getFocusedView2 ? void 0 : _this$getFocusedView2.element()
    }
    keyDownHandler(e) {}
    initKeyDownHandler() {
        this.unsubscribeFromKeyDownEvent();
        this.subscribeToKeyDownEvent()
    }
    getFocusinSelector() {
        return ""
    }
    focusinHandler(e) {}
    initHandlers() {
        var _focusedView$renderCo, _this$_resizeControll;
        const focusedView = this.getFocusedView();
        this.unsubscribeFromKeyDownEvent();
        null === focusedView || void 0 === focusedView || null === (_focusedView$renderCo = focusedView.renderCompleted) || void 0 === _focusedView$renderCo || _focusedView$renderCo.remove(this.renderCompletedWithContext);
        null === (_this$_resizeControll = this._resizeController) || void 0 === _this$_resizeControll || null === (_this$_resizeControll = _this$_resizeControll.resizeCompleted) || void 0 === _this$_resizeControll || _this$_resizeControll.remove(this.resizeCompletedWithContext);
        if (this.isKeyboardEnabled()) {
            var _focusedView$renderCo2, _this$_resizeControll2;
            null === focusedView || void 0 === focusedView || null === (_focusedView$renderCo2 = focusedView.renderCompleted) || void 0 === _focusedView$renderCo2 || _focusedView$renderCo2.add(this.renderCompletedWithContext);
            null === (_this$_resizeControll2 = this._resizeController) || void 0 === _this$_resizeControll2 || null === (_this$_resizeControll2 = _this$_resizeControll2.resizeCompleted) || void 0 === _this$_resizeControll2 || _this$_resizeControll2.add(this.resizeCompletedWithContext)
        }
    }
    getFocusedView() {}
    _getCell(cellPosition) {}
    _getRowIndex($row) {
        return null === $row || void 0 === $row ? void 0 : $row.index()
    }
    getCellIndex($cell, rowIndex) {
        return null === $cell || void 0 === $cell ? void 0 : $cell.index()
    }
    _getFixedColumnIndexOffset(column) {
        const visibleColumnCount = this._columnsController.getVisibleColumns(null, true).length;
        const offset = (0, _m_keyboard_navigation_utils.isFixedColumnIndexOffsetRequired)(this, column) ? visibleColumnCount - this._columnsController.getVisibleColumns().length : 0;
        return offset
    }
    getNewVisibleIndex(visibleIndex, rowIndex, direction) {
        return "previous" === direction ? visibleIndex - 1 : visibleIndex + 1
    }
    _getCellPosition($cell, direction) {
        const $row = (0, _m_keyboard_navigation_utils.isElementDefined)($cell) && $cell.closest("tr");
        if ((0, _m_keyboard_navigation_utils.isElementDefined)($row)) {
            const rowIndex = this._getRowIndex($row);
            let columnIndex = this.getCellIndex($cell, rowIndex);
            columnIndex += this.getColumnIndexOffset(columnIndex);
            if (direction) {
                columnIndex = this.getNewVisibleIndex(columnIndex, rowIndex, direction);
                columnIndex = this._applyColumnIndexBoundaries(columnIndex)
            }
            return {
                rowIndex: rowIndex,
                columnIndex: columnIndex
            }
        }
        return
    }
    _getColumnByCellElement($cell, rowIndex) {
        const cellIndex = this.getCellIndex($cell);
        const columnIndex = cellIndex + this._columnsController.getColumnIndexOffset();
        return this._columnsController.getVisibleColumns(rowIndex, true)[columnIndex]
    }
    processOnKeyDown(eventArgs) {
        const {
            originalEvent: originalEvent
        } = eventArgs;
        const args = {
            handled: false,
            event: originalEvent
        };
        this.executeAction("onKeyDown", args);
        eventArgs.ctrl = originalEvent.ctrlKey;
        eventArgs.alt = originalEvent.altKey;
        eventArgs.shift = originalEvent.shiftKey;
        return !!args.handled
    }
    setFocusedColumnIndex(columnIndex) {
        if (!this._focusedCellPosition) {
            this._focusedCellPosition = {}
        }
        this._focusedCellPosition.columnIndex = columnIndex
    }
    _updateFocusedCellPosition($cell, direction) {
        const position = this._getCellPosition($cell, direction);
        if (position) {
            if (!$cell.length || position.rowIndex >= 0 && position.columnIndex >= 0) {
                this.setFocusedCellPosition(position.rowIndex, position.columnIndex)
            }
        }
        return position
    }
    renderCompleted(e) {
        this.initKeyDownHandler();
        this.unsubscribeFromFocusinEvent();
        this.subscribeToFocusinEvent()
    }
    getScrollable() {
        return this._rowsView.getScrollable()
    }
    scrollLeft(scrollLeft) {
        const scrollable = this.getScrollable();
        if (!scrollable || scrollable.scrollLeft() === scrollLeft) {
            return (0, _deferred.Deferred)().resolve().promise()
        }
        const d = (0, _deferred.Deferred)();
        const scrollHandler = () => {
            var _this$_columnsControl;
            scrollable.off("scroll", scrollHandler);
            const normalizeScrollLeft = this._rowsView.normalizeScrollLeft(scrollLeft);
            if (null !== (_this$_columnsControl = this._columnsController) && void 0 !== _this$_columnsControl && _this$_columnsControl.isNeedToRenderVirtualColumns(normalizeScrollLeft)) {
                const renderCompletedHandler = () => {
                    this._rowsView.renderCompleted.remove(renderCompletedHandler);
                    d.resolve()
                };
                this._rowsView.renderCompleted.add(renderCompletedHandler)
            } else {
                d.resolve()
            }
        };
        scrollable.on("scroll", scrollHandler);
        scrollable.scrollTo({
            left: scrollLeft
        });
        return d.promise()
    }
    scrollToNextCell($nextCell, direction) {
        const scrollLeft = this.getNextCellLocation($nextCell, direction);
        return this.scrollLeft(scrollLeft)
    }
    _isVirtualColumnRender() {
        return "virtual" === this.option("scrolling.columnRenderingMode")
    }
    getContainerBoundingRect($container) {
        const containerRect = (0, _position.getBoundingRect)($container.get(0));
        return {
            left: containerRect.left,
            right: containerRect.right
        }
    }
    init() {
        this._columnsController = this.getController("columns");
        this._resizeController = this.getController("resizing");
        this._rowsView = this.getView("rowsView");
        this._focusedCellPosition = {};
        if (this.isKeyboardEnabled()) {
            this.createAction("onKeyDown")
        }
        this.renderCompletedWithContext = this.renderCompletedWithContext ?? this.renderCompleted.bind(this);
        this.resizeCompletedWithContext = this.resizeCompletedWithContext ?? this.resizeCompleted.bind(this);
        this.focusinHandlerContext = this.focusinHandlerContext ?? this.focusinHandler.bind(this);
        this.initHandlers()
    }
    dispose() {
        _short.keyboard.off(this.keyDownListener)
    }
    setFocusedRowIndex(rowIndex) {
        if (!this._focusedCellPosition) {
            this._focusedCellPosition = {}
        }
        this._focusedCellPosition.rowIndex = rowIndex
    }
    setFocusedCellPosition(rowIndex, columnIndex) {
        this.setFocusedRowIndex(rowIndex);
        this.setFocusedColumnIndex(columnIndex)
    }
    optionChanged(args) {
        switch (args.name) {
            case "keyboardNavigation":
                if ("keyboardNavigation.enabled" === args.fullName) {
                    this.init()
                }
                args.handled = true;
                break;
            case "useLegacyKeyboardNavigation":
                this.init();
                args.handled = true;
                break;
            default:
                super.optionChanged(args)
        }
    }
    isKeyboardEnabled() {
        return this.option("keyboardNavigation.enabled")
    }
    _getFocusedCell() {
        return (0, _renderer.default)(this._getCell(this._focusedCellPosition))
    }
    getDirectionByKeyName(keyName) {
        const rtlEnabled = this.option("rtlEnabled");
        switch (keyName) {
            case "leftArrow":
                return rtlEnabled ? _const.Direction.Next : _const.Direction.Previous;
            case "rightArrow":
                return rtlEnabled ? _const.Direction.Previous : _const.Direction.Next;
            default:
                return _const.Direction.Next
        }
    }
}
exports.KeyboardNavigationController = KeyboardNavigationController;
